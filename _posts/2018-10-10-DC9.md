---
title: "Manipulating DataFrames with pandas"
date: 2018-10-10
tags: [python]
header:
  images:
excerpt: "Manipulating DataFrames with pandas"
---

## Positional and labeled indexing
Given a pair of label-based indices, sometimes it's necessary to find the corresponding positions. We will use the Pennsylvania election results again. The DataFrame is provided for us as election. Find x and y such that election.iloc[x, y] == election.loc['Bedford', 'winner']. That is, what is the row position of 'Bedford', and the column position of 'winner'? Remember that the first position in Python is 0, not 1! To answer this question, first explore the DataFrame using election.head() in the Python Shell and inspect it with our eyes.

```python
# Assign the row position of election.loc['Bedford']: x
x = 4
# Assign the column position of election['winner']: y
y = election.columns.get_loc('winner')
# Print the boolean equivalence
print(election.iloc[x, y] == election.loc['Bedford', 'winner'])
```

## Indexing and column rearrangement
There are circumstances in which it's useful to modify the order of your DataFrame columns. We do that now by extracting just two columns from the Pennsylvania election results DataFrame. Our job is to read the CSV file and set the index to 'county'. We'll then assign a new DataFrame by selecting the list of columns ['winner', 'total', 'voters']. The CSV file is provided to us in the variable filename.

```python
# Import pandas
import pandas as pd
# Read in filename and set the index: election
election = pd.read_csv(filename, index_col='county')
# Create a separate dataframe with the columns ['winner', 'total', 'voters']: results
results = election[['winner', 'total', 'voters']]
# Print the output of results.head()
print(results.head())
```

## Slicing rows
The Pennsylvania US election results data set that we have been using so far is ordered by county name. This means that county names can be sliced alphabetically. In this exercise, we're going to perform slicing on the county names of the election DataFrame.

```python
# Slice the row labels 'Perry' to 'Potter': p_counties
p_counties =  election.loc['Perry':'Potter']
# Print the p_counties DataFrame
print(p_counties)
# Slice the row labels 'Potter' to 'Perry' in reverse order: p_counties_rev
p_counties_rev =  election.loc['Potter':'Perry':-1]
# Print the p_counties_rev DataFrame
print(p_counties_rev)
```

## Slicing columns
Similar to row slicing, columns can be sliced by value. In this exercise, our job is to slice column names from the Pennsylvania election results DataFrame using .loc[].

```python
# Slice the columns from the starting column to 'Obama': left_columns
left_columns = election.loc[:,:'Obama']

# Print the output of left_columns.head()
print(left_columns.head())
# Slice the columns from 'Obama' to 'winner': middle_columns
middle_columns = election.loc[:,'Obama':'winner']
# Print the output of middle_columns.head()
print(middle_columns.head())
# Slice the columns from 'Romney' to the end: 'right_columns'
right_columns = election.loc[:,'Romney':]
# Print the output of right_columns.head()
print(right_columns.head())
```

## Subselecting DataFrames with lists
We can use lists to select specific row and column labels with the .loc[] accessor. In this exercise, our job is to select the counties ['Philadelphia', 'Centre', 'Fulton'] and the columns ['winner','Obama','Romney'] from the election DataFrame, which has been pre-loaded with the index set to 'county'.

```python
# Create the list of row labels: rows
rows = ['Philadelphia', 'Centre', 'Fulton']
# Create the list of column labels: cols
cols = ['winner', 'Obama', 'Romney']
# Create the new DataFrame: three_counties
three_counties = election.loc[rows,cols]
# Print the three_counties DataFrame
print(three_counties)
```
